---
title: "Measurement of Capabilities: Tables and Figures: `r params$lwr_year` - `r params$upr_year`"
format: docx
execute:
    echo: false
    warning: false
    fig_width: 8
    fig_height: 6
    fig-dpi: 450
params:
    lwr_year: 2019
    upr_year: 2024
---

```{r}
#| label: setup
library(tidyverse)
library(here)
library(ggthemes)
library(Hmisc)
library(httr)
library(patchwork)
library(flextable)
library(ggtext)
library(estimatr)
library(assertthat)
library(fixest)
library(modelsummary)
library(ggrepel)
library(zoo)
library(haven)
library(readxl)
# set directories
# dir <- here()
dir <- "C:/Users/wb599047/Downloads/Measurement_Capabilities/Measurement_Capabilities/"

# set directories
raw_dir <- paste0(dir, "01_raw_data/")
output_dir <- paste0(dir, "03_output/")

```

```{r}
#| label: params
# get the years for the data (default is a ten year window since 2015)
lower_year <- params$lwr_year
upper_year <- params$upr_year
span <- c(lower_year:upper_year)

# exclude countries with small populations
pop_filt <- 200000
# Countries with populations of less than 200,000 (34 out of 215 countries in the UN SDG Database) were excluded from this analysis. These are: American Samoa, Andorra, Antigua and Barbuda, Aruba, Bermuda, British Virgin Islands, Cayman Islands, Channel Islands, Curacao, Dominica, Faroe Islands, Gibraltar, Greenland, Grenada, Guam, Isle of Man, Kiribati, Liechtenstein, Marshall Islands, Micronesia, Fed. Sts., Monaco, Nauru, Northern Mariana Islands, Palau, San Marino, Seychelles, Sint Maarten (Dutch part), St. Kitts and Nevis, St. Lucia, St. Martin (French part), St. Vincent and the Grenadines, Tonga, Turks and Caicos Islands, Tuvalu, Virgin Islands (U.S.).  In general, small islands and nations are under-performers in terms of statistical performance conditional on their income and human captial index level (Dang et al 2021).


```


```{r}
#| label: loadwbdata

# read in the main data for the paper. This includes some metadata on SDG indicators, a list of HD/child related indicators, and the UN sdg data itself.

# get a list of all SDG indicators from the UN API
# bring in the list of indicators
sdg_list_df <- read_csv(paste0(raw_dir, "metadata/SDG_indicator_list.csv"))

# get a list of UN ISO codes for countries
iso3c <- read_csv(paste0(raw_dir, "iso_codes.csv"),
    col_types = list(col_character(), col_character(), col_character())
)

# Also get world bank metadata
wb_metadata <- read_csv(paste0(raw_dir, "metadata/", "wb_country_metadata.csv")) %>%
    # keep just the countries
    filter(region != "Aggregates")

# read in some data from WDI
# Indicators pulled from the WDI:
# - Government expenditure per student, primary (% of GDP per capita) (SE.XPD.PRIM.PC.ZS)
# - Government expenditure per student, secondary (% of GDP per capita) (SE.XPD.SECO.PC.ZS)
# - Government expenditure per student, tertiary (% of GDP per capita) (SE.XPD.TERT.PC.ZS)
# - GDP per capita, PPP (constant 2021 international $) (NY.GDP.PCAP.PP.KD)
# - Population, Total (SP.POP.TOTL)
# - Learning poverty: Share of Children at the End-of-Primary age below minimum reading proficiency adjusted by Out-of-School Children (%) (SE.LPV.PRIM)
# - Primary school age children out-of-school (%) (SE.LPV.PRIM.SD)
# - Pupils below minimum reading proficiency at end of primary (%). Low GAML threshold (SE.LPV.PRIM.LD)

wdi_df <- read_csv(paste0(raw_dir, "wb_data/", "wdi_data.csv")) %>%
  #create a population measure for the number of kids under age 25
  mutate(population_under25=SP.POP.0004.FE+ SP.POP.0004.MA + 
                            SP.POP.0509.FE + SP.POP.0509.MA + 
                            SP.POP.1014.FE + SP.POP.1014.MA + 
                            SP.POP.1519.FE + SP.POP.1519.MA + 
                            SP.POP.2024.FE + SP.POP.2024.MA,
         #population 5 to 14
         population_5_14=SP.POP.0509.FE + SP.POP.0509.MA + 
                            SP.POP.1014.FE + SP.POP.1014.MA,
         #population under 5
         population_under5=SP.POP.0004.FE+ SP.POP.0004.MA) 

#read in Global Dataset of Country Learning Assessments
#This data is pulled to supplement the learning assessment information in the World Bank API
# This is the most up to date version, while the World Bank API might have an older vintage
#download file and save excel at path 'https://datacatalogfiles.worldbank.org/ddh-published/0064204/DR0090935/clo_edstats_2022.xls?versionId=2024-08-07T18:19:46.4515428Z'

clo_df <- read_excel(paste0(raw_dir, "wb_data/", "country_learning_outcomes.xls"),
                     sheet="CLO_indicators")

#merge the clo data to the wb_data already loaded
# this will offer supplemental information learning assessment availability

#prepare clo data for merge. Transform data so that each country has one row per year. The row will be an indicator of a learning assessment
clo_df_prep <- clo_df %>%
  group_by(countrycode, year) %>%
  summarise(
    #check for availability of data for any of the clo indicators. This will indicate that a learning assessment took place
    clo_avail = max(!is.na(value), na.rm = TRUE)
  ) %>%
  rename(
   iso3c=countrycode,
   date=year
  )

#merge to wb_data
wdi_df <- wdi_df %>%
  left_join(clo_df_prep, by=c("iso3c", "date")) 

#supplement with learning poverty data on enrollment
lpov_enrollment_df <- read_dta(paste0(raw_dir, "wb_data/", "lpov_enrollment.dta")) %>%
  rename(
    iso3c=countrycode,
    date=year
  )

# get list of countries to exclude due to small populations
pop_exlude_cntry <- wdi_df %>%
    filter(date == 2023) %>%
    filter(SP.POP.TOTL <= pop_filt) %>%
    select(iso3c) %>%
    pluck(1)
pop_exlude_cntry_names <- wdi_df %>%
    left_join(wb_metadata) %>%
    filter(date == 2023) %>%
    filter(SP.POP.TOTL <= pop_filt) %>%
    select(country) %>%
    pluck(1)

# get span of years covered by the data
span <- c(lower_year:upper_year)


```

```{r}
#| label: combineotherdata

#combine the World Bank data with other data from UN CRVS database and Stunting data from JME. 

#SDG Indicator 2.2.1 (Prevalence of stunting (height for age <-2 standard deviation from the median of the World Health Organization (WHO) Child Growth Standards) among children under 5 years of age). This indicator is classified as modelled data in the UN SDG database. However the data custodian, UNICEF/WHO/The World Bank: Joint child malnutrition estimates (JME), publishes the underlying survey data used prior to modelling.
jme_survey_data <- read_excel(paste0(raw_dir, "other_data/jme-by-country-april2024.xlsx"),
                              sheet="April 2024") %>%
  transmute(
    iso3c=`ISO code`,
    Stunting=Stunting,
    date= `Year*`
  )

# UN CRVS data
# read list of iso3c codes for matching from UN (https://unstats.un.org/unsd/methodology/m49/)
iso3c <- read_csv(paste0(raw_dir, "iso_codes.csv"),
  col_types = list(col_character(), col_character(), col_character())
)

un_crvs_completeness <- read_csv(paste0(raw_dir, "sdg_data/raw/SG_REG_BRTH_RAW.csv")) %>%
    group_by(GeoAreaCode) %>%
    mutate(
      #get a flag if the <5Y value is available. If not then get average of all values
      flag=if_else(`[Age]`=="<5Y", 1, 0),
    )

#subset data with <5Y
un_crvs_completeness_age5 <- un_crvs_completeness %>%
  filter(flag==1) %>%
  select(GeoAreaCode, TimePeriod, `[Nature]`, Value) 

#add other data if missing for GeoAreaCode
un_crvs_completeness_other <- un_crvs_completeness %>%
  group_by(GeoAreaCode) %>%  
  filter(max(flag)==0) %>%
  group_by(GeoAreaCode, TimePeriod, `[Nature]`) %>%
  summarise(
    Value=mean(Value, na.rm=TRUE)
  ) %>%
  ungroup()


#append data together
un_crvs_completeness <- un_crvs_completeness_age5 %>%
  bind_rows(un_crvs_completeness_other) %>%
    mutate(
      date = as.numeric(TimePeriod),
      Nature = `[Nature]`,
      geoAreaCode = as.character(GeoAreaCode)
    ) %>%
  left_join(iso3c) %>%
  transmute(
    iso3c=iso3c,
    birth_registration_under5=Value,
    date= as.numeric(TimePeriod)
  ) %>%
  filter(!is.na(iso3c))
            
# merge the data with wdi
wdi_df <- wdi_df %>%
  left_join(jme_survey_data) %>%
  left_join(un_crvs_completeness)


```


```{r}
#| label: loadunstats
# read in a list of HD/child related indicators
child_sdgs_df <- read_csv(paste0(raw_dir, "Child_SDGs.csv"),
    col_types = list(
        goal = col_double(),
        target = col_character()
    )
) %>%
    mutate(All_SDGs = 1) %>%
    select(-tier, -description) # drop fields that are already in the main dataset, and could change overtime causing merge issue

# merge the two datasets
sdg_list_df <- sdg_list_df %>%
    left_join(child_sdgs_df)

# now read in the UN data. This data has already been prepared in the data preparation script (un_stats_cleaning.qmd). It comtains the data for each of the UN series. It contains the data for each of the UN series. There are 249 unique iso3c codes in the data. There are 753 codes
un_sdg_data_df <- read_csv(paste0(output_dir, "un_sdg_df.csv"))

# Process data so that we have data on availability of data over the past ten or so (Defined above) years.
# For each indicator, we will produce a value for each country with the following coding scheme:

# **1 Point**: Indicator exists and the value is based on the **country**, **country data adjusted**, or **estimated or Global Monitoring** data
# **0 Points**: Indicator **based on modeled data or does not exists**
country_data_availability_df <- un_sdg_data_df %>%
    filter(between(date, lower_year, upper_year)) %>%
    # add any available category that counts modelled
    mutate(
        any_available = if_else(ind_available==1, 1, ind_modelled)
    ) %>%
    group_by(iso3c, code, goal) %>% # aggregat by country and SDG indicator
    summarise(
        any_available = max(any_available, na.rm = T), # a 0/1 indicator if there is data available in the window
        ind_available = max(ind_available, na.rm = T), # a 0/1 indicator if there is nonmodelled data available in the window
        ind_modelled = max(ind_modelled, na.rm = T), # a 0/1 indicator if the data is modelled
        ind_value = mean(ind_value, na.rm = T), # just takes the average value as a potential coveriate
        ind_metadata = first(ind_metadata) # takes the most recent value level indicator if available as additoinal background info
    ) %>% # check if any values (even sub-indicators) for indicator
    mutate(
        any_available = if_else(is.na(any_available) | is.infinite(any_available), 0, any_available),
        ind_available = if_else(is.na(ind_available) | is.infinite(ind_available), 0, ind_available),
        ind_modelled = if_else(is.na(ind_modelled) | is.infinite(ind_modelled), 0, ind_modelled),
    ) %>% # if there is no data, set availability to 0
    left_join(wb_metadata) %>%
    filter(!is.na(region)) %>%
    # drop small population countries
    filter(!iso3c %in% pop_exlude_cntry) %>%
    left_join(child_sdgs_df) # add SDG classifications


# collapse to the indicator level to average across countries
indicator_availability_df <- country_data_availability_df %>%
    group_by(code, goal) %>%
    summarise(
        any_available = mean(any_available, na.rm = T),
        ind_available = mean(ind_available, na.rm = T),
        ind_modelled = mean(ind_modelled, na.rm = T), # modelled observations
        ind_value = mean(ind_value, na.rm = T),
        ind_metadata = first(ind_metadata),
        n_countries = n()
    ) %>%
    left_join(child_sdgs_df) %>% # add SDG classifications %>%
    left_join(
        read_csv(paste0(raw_dir, "Child_SDGs.csv"),
            col_types = list(
                goal = col_double(),
                target = col_character()
            )
        ) %>%
            select(code, tier, description)
    )

# The first dataset shows the availability of any data for the SDG. In what follows, we will look specifically for age related disaggregations availabile in the data

# define age categories to look for. This was done by a manual review of codes available in UN SDG data
age_codelist <- c(
    "<15Y", "15-24", "<18Y", "<10Y", "<16Y", "<6Y", "<5Y", "<1Y", "<1M",
    "10-14", "15-19", "20-24", "10+", "12+", "12-24", "3+", "12-14", "16+",
    "6+", "5+", "14+", "18+", "5-17", "5-14", "10-17", "6-17", "7-17", "1-14",
    "2-14", "5-12", "1-4", "<25Y", "M12T23", "<8Y"
)

un_sdg_age_data_df <- read_csv(paste0(output_dir, "un_sdg_age_df.csv"))


country_age_data_availability_df <- un_sdg_age_data_df %>%
    filter(between(date, lower_year, upper_year)) %>%
    # filter based on relevant age groupings
    mutate(
        ind_available = if_else(
            Age %in% age_codelist & ind_available == 1, 1, 0
        ),
        ind_value = if_else(
            Age %in% age_codelist & ind_available == 1, ind_value, NA_real_
        ),
        ind_modelled = if_else(
            Age %in% age_codelist & ind_available == 1, ind_modelled, NA_real_
        ),
        ind_metadata = if_else(
            Age %in% age_codelist & ind_available == 1, ind_metadata, as.character(NA)
        )
    ) %>%
    group_by(iso3c, code, goal) %>% # aggregat by country and SDG indicator
    summarise(
        age_available = max(ind_available, na.rm = T), # a 0/1 indicator if there is data available in the window
        age_modelled = max(ind_modelled, na.rm = T), # a 0/1 indicator if the data is modelled
        age_value = mean(ind_value, na.rm = T), # just takes the average value as a potential coveriate
        age_metadata = first(ind_metadata) # takes the most recent value level indicator if available as additoinal background info
    ) %>% # check if any values (even sub-indicators) for indicator
    mutate(
        age_available = if_else(is.na(age_available) | is.infinite(age_available), 0, age_available),
        age_modelled = if_else(is.na(age_modelled) | is.infinite(age_modelled), 0, age_modelled),
    ) %>% # if there is no data, set availability to 0
    left_join(wb_metadata) %>%
    filter(!is.na(region)) %>%
    # drop small population countries
    filter(!iso3c %in% pop_exlude_cntry) %>%
    left_join(child_sdgs_df) # add SDG classifications


# collapse to the indicator level to average across countries
indicator_age_availability_df <- country_age_data_availability_df %>%
    group_by(code, goal) %>%
    summarise(
        age_available = mean(age_available, na.rm = T),
        age_modelled = mean(age_modelled, na.rm = T), # modelled observations
        age_value = mean(age_value, na.rm = T),
        age_metadata = first(age_metadata),
        n_countries = n()
    ) %>%
    left_join(child_sdgs_df) %>% # add SDG classifications %>%
    left_join(
        read_csv(paste0(raw_dir, "Child_SDGs.csv"),
            col_types = list(
                goal = col_double(),
                target = col_character()
            )
        ) %>%
            select(code, tier, description)
    )



# join the two datasets with a column for any data available and age data available
country_data_availability_combined_df <- country_data_availability_df %>%
    left_join(country_age_data_availability_df) %>%
    # create a new column that is the intersection of the two availability columns
    # this column is the share of countries with an indicator that is age disaggregated when it is supposed to be
    mutate(
        availability = case_when(
            Flag_Check_Age_ChildrenSeparate == 1 ~ age_available,
            TRUE ~ ind_available
        ),
        # if missing age when it is supposed to exist, then set to 0
        availability = if_else(is.na(availability) & Flag_Check_Age_ChildrenSeparate == 1, 0, availability)
    )

# do same for indicator availability dataframes
indicator_availability_combined_df <- indicator_availability_df %>%
    left_join(indicator_age_availability_df)

```

```{r}
#| label: datachecks
#| echo: false
#| output: false

# do some basic checks to make sure the data is behaving as expected.

# check 1. The number of unique iso3c codes in the data
# The UN data should have 249 unique iso3c codes
assert_that(nrow(un_sdg_data_df %>% distinct(iso3c)) == 249)

# the data availability data should have 181 country codes, which is the intersetion between the countries in the UN and World Bank data, because it is restricted to world bank coutnries. The Channel Islands and Kosovo are not included in the UN data, but are in the World Bank data. Countries with a smaller population are also dropped
assert_that(length(unique(country_data_availability_combined_df$iso2c)) == 181)

# check 2. The span of years should be 21 (2004-2024)
assert_that(unique(un_sdg_data_df$date) %>% length() == 21)

# check 3. The number of unique indicators in the data
# there should be 248 unique SDGs
assert_that(length(unique(country_data_availability_combined_df$code)) == 248)

```



```{r}
#| label: programs

# set color palletes
region_colors <- c(
    "North America" = "#F0E442",
    "Europe & Central Asia" = "#D55E00",
    "Sub-Saharan Africa" = "#0072B2",
    "East Asia & Pacific" = "#CC79A7",
    "Latin America & Caribbean" = "#009E73",
    "Middle East & North Africa" = "#56B4E9",
    "South Asia" = "#E69F00"
)

income_colors <- c(
    "Low income" = "#D81B60",
    "Lower middle income" = "#FFC107",
    "Upper middle income" = "#1E88E5",
    "High income" = "#004D40"
)


# add equations to plots
eq_plot_txt <- function(data, inp, var) {
    eq <- lm_robust(data[[var]] ~ data[[inp]], data = data, se_type = "HC2")
    coef <- round(coef(eq), 2)
    std_err <- round(sqrt(diag(vcov(eq))), 2)
    r_2 <- round(summary(eq)$r.squared, 2)
    sprintf(" y = %.2f + %.2f x, R<sup>2</sup> = %.2f <br> (%.2f) <span style='color:white'> %s</span> (%.2f) ", coef[1], coef[2], r_2[1], std_err[1], "s", std_err[2])
}

FitFlextableToPage <- function(ft, pgwidth = 6) {
    ft_out <- ft %>%
        autofit()

    ft_out <- width(ft_out, width = dim(ft_out)$widths * pgwidth / (flextable_dim(ft_out)$widths))
    return(ft_out)
}


theme_spi <- function() {
    theme_bw() %+replace%
        theme(
            plot.caption = element_text(hjust = 0),
            plot.title = element_blank() # remove all titles from plots (sometimes we may need to bring title outside plot)
        )
}
# define stle for ggplot based on BBC plotting styles
bbc_style <- function() {
    font <- "Helvetica"

    ggplot2::theme(

        # Text format:
        # This sets the font, size, type and colour of text for the chart's title
        plot.title = ggplot2::element_text(
            family = font,
            size = 18,
            face = "bold",
            color = "#222222"
        ),
        # This sets the font, size, type and colour of text for the chart's subtitle, as well as setting a margin between the title and the subtitle
        plot.subtitle = ggplot2::element_text(
            family = font,
            size =  16,
            margin = ggplot2::margin(9, 0, 9, 0)
        ),
        # plot.caption = ggplot2::element_blank(),
        # This leaves the caption text element empty, because it is set elsewhere in the finalise plot function

        # Legend format
        # This sets the position and alignment of the legend, removes a title and backround for it and sets the requirements for any text within the legend. The legend may often need some more manual tweaking when it comes to its exact position based on the plot coordinates.
        legend.position = "top",
        legend.text.align = 0,
        legend.background = ggplot2::element_blank(),
        legend.title = ggplot2::element_blank(),
        legend.key = ggplot2::element_blank(),
        legend.text = ggplot2::element_text(
            family = font,
            size = 14,
            color = "#222222"
        ),

        # Axis format
        # This sets the text font, size and colour for the axis test, as well as setting the margins and removes lines and ticks. In some cases, axis lines and axis ticks are things we would want to have in the chart - the cookbook shows examples of how to do so.
        axis.title = ggplot2::element_text(
            family = font,
            size = 16,
            color = "#222222"
        ),
        axis.text = ggplot2::element_text(
            family = font,
            size = 16,
            color = "#222222"
        ),
        axis.text.x = ggplot2::element_text(margin = ggplot2::margin(5, b = 10)),
        axis.ticks = ggplot2::element_blank(),
        axis.line = ggplot2::element_blank(),

        # Grid lines
        # This removes all minor gridlines and adds major y gridlines. In many cases you will want to change this to remove y gridlines and add x gridlines. The cookbook shows you examples for doing so
        panel.grid.minor = ggplot2::element_blank(),
        panel.grid.major.x = ggplot2::element_line(color = "#cbcbcb"),
        panel.grid.major.y = ggplot2::element_blank(),

        # Blank background
        # This sets the panel background as blank, removing the standard grey ggplot background colour from the plot
        panel.background = ggplot2::element_blank(),

        # Strip background (#This sets the panel background for facet-wrapped plots to white, removing the standard grey ggplot background colour and sets the title size of the facet-wrap title to font size 22)
        strip.background = ggplot2::element_rect(fill = "white"),
        strip.text = ggplot2::element_text(size = 22, hjust = 0)
    )
}

```



Reproducibility package for Tables and Figures in the paper "To improve wellbeing globally, we need more data on children" by Alaka Holla, Mamta Murthi, and Brian Stacy

# Main Tables and Figures

## Figure 1. Outcomes vs. inputs

[This is a figure that is a scatter of minimum proficiency and primary school enrolment, country-level. Y axis is percentage enrolled in primary school and X axis is percentage of children reaching minimum proficiency. ]

```{r}
#| label: fig1
#| fig-cap: "Outcomes vs. inputs"
#| fig-width: 10
#| fig-height: 8
# read in data from the WDI
lpov_df <- wdi_df %>%
  #join with learning poverty enrollment
  left_join(lpov_enrollment_df) %>%
    # adjust cells with zero values for SE.LPV.PRIM.LD,  SE.LPV.PRIM.SD
    mutate(
        SE.LPV.PRIM.LD = ifelse(SE.LPV.PRIM.LD == 0, 0.01, SE.LPV.PRIM.LD),
        SE.LPV.PRIM.SD = ifelse(SE.LPV.PRIM.SD == 0, 0.01, SE.LPV.PRIM.SD),
        # create log10 values
        log_SE.LPV.PRIM.LD = log10(SE.LPV.PRIM.LD),
        log_SE.LPV.PRIM.SD = log10(SE.LPV.PRIM.SD),

    ) %>%
    # recode so that instead of out of school we have in school and instead of below minimumu proficiency we have above minimum proficiency
    mutate(
        in_school = 100 - SE.LPV.PRIM.SD,
        proficient = 100 - SE.LPV.PRIM.LD,
        # create log10 values
        log_in_school = log10(in_school),
        log_proficient = log10(proficient)
    ) %>%
    group_by(iso3c) %>%
    #for enrollment get the value for the year 2010
    mutate(
        high_enrollment_count = sum(enrollment_validated_all >85, na.rm=TRUE) #number of years with high enrollment since 2000
        #enrollment_2010 = enrollment_validated_all[date == 2010]
    ) %>%    # keep latest non-missing value for each country
    filter(
        !is.na(SE.LPV.PRIM.LD),
        !is.na(SE.LPV.PRIM.SD)
    ) %>%
    filter(date == max(date)) %>%
    ungroup() %>%
    #create enrollment groups based on high_enrollment_count (0 years, 1-5 years, 6-10 years, 11-15 years, 16-20 years)
    mutate(
        enrollment_group = case_when(
            high_enrollment_count == 0 ~ "0 years",
            high_enrollment_count <= 10 ~ "1-10 years",
            high_enrollment_count <= 20 ~ "11-20 years",
            TRUE ~ "21+ years"
        )
    ) 

# location of equation
location <- data.frame(
    x = 10,
    y = 30
)

# scatterplot   Primary school age children out-of-school (%) (SE.LPV.PRIM.SD) and Pupils below minimum reading proficiency at end of primary (%). Low GAML threshold (SE.LPV.PRIM.LD)

enrollment_colors <- c(
    "0 years" = "#9e2f59",
    "1-10 years" = "#ed8e3f",
    "11-20 years" = "#abd786",
    "21+ years" = "#22789d"
  
)



ggplot(lpov_df, aes(y = in_school, x = proficient, color = enrollment_group, label = iso3c)) +
    #geom_text_repel() +
    geom_point(aes(size = population_5_14)) +
    # geom_smooth(method = "lm", se = FALSE) +
    labs(
        y = "Primary school age children in-school (%)",
        x = "Pupils above minimum reading proficiency at end of primary (%)",
        # title = str_wrap("Countries above the 45 degree line are doing relatively worse on outcomes than inputs.", 60),
        # subtitle=str_wrap('Countries are colored on the basis of the number of years they have had high primary school enrollment rates (>85%) since 2000. ', 80),
        color=str_wrap("Years with high (>85%) primary school enrollment rates since 2000", 30)
    ) +
    scale_size_continuous(range = c(2,6),
                          guide=FALSE) +

    expand_limits(
        x = c(0, 100),
        y = c(0, 100)
    ) +
    scale_color_manual(values = enrollment_colors) +
    #geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
    # log scale
    # scale_x_log10(
    #     labels = scales::label_percent(scale = 1)
    # ) +
    # scale_y_log10(
    #     labels = scales::label_percent(scale = 1)
    # ) +
    # geom_richtext(
    #     data = location, aes(x = x, y = y, label = eq_plot_txt(wdi_df, "SE.LPV.PRIM.LD", "SE.LPV.PRIM.SD")), hjust = 0.2
    # ) +
    bbc_style() +
    theme(
      legend.position = "bottom",
      #display legend label
      legend.title = element_text(size = 10),
    )


```

Note: Dots are sized on the basis of population.



## Figure 2. The measurement of outcomes in the SDGs

[This is a figure that demonstrates with colors the proportion of indicators in the HD-related SDGs that are outcomes; the proportion that are inputs; The indicators will be at the higher-level (N=231), not all the component series (N=753). There will be two panels – (a) for all HD indicators and (b) for the set restricted to children.]


```{r}
#| label: fig2data

# prepare the data for the plot
data_outcome_input_share <- function(ind_list, name) {
    # prepare the data for the plot
    # count the number of indicators that are outcomes and inputs


    share <- indicator_availability_combined_df %>%
        ungroup() %>%
        #drop duplicates based on description
        distinct(description, .keep_all = TRUE) %>%
        #drop code 13.b.1 because it is a duplicate of 13.2.1
        filter(code != "13.b.1") %>%
        rename(sdgs = !!ind_list) %>%
        filter(sdgs == 1) %>%
        mutate(
            type = case_when(
                Outcome_Functioning_SDG == 1 ~ "Outcome",
                Input_Capability_SDG == 1 ~ "Input",
                TRUE ~ "Other"
            )
        ) %>%
        group_by(type) %>%
        summarise(count = n()) %>%
        # add share
        ungroup() %>%
        mutate(share = round(count / sum(count), 2)) %>%
        mutate(name = name) %>%
        select(name, everything()) %>%
        mutate(type = factor(type, levels = c("Outcome", "Input", "Other"))) %>%
        arrange(type)
}

plot_data <- bind_rows(
    data_outcome_input_share("All_SDGs", "All SDG indicators"),
    data_outcome_input_share("HD_SDG", "Human Development\n indicators"),
    data_outcome_input_share("Child_SDG", "Child indicators")
) %>%
  mutate(name = factor(name, levels = c("All SDG indicators", "Human Development\n indicators", "Child indicators")))


```


```{r}
#| label: fig2_alt
#| fig-cap: "The measurement of outcomes in the SDGs"
#| fig-height: 6
#| fig-width: 11

# donut plot


# Compute the cumulative percentages (top of each rectangle)
plot_data$ymax <- cumsum(plot_data$share)

# Compute the bottom of each rectangle
plot_data$ymin <- c(0, head(plot_data$ymax, n=-1))

# Compute label position
plot_data$labelPosition <- (plot_data$ymax + plot_data$ymin) / 2

# Compute a good label
plot_data$label <- paste0(plot_data$type, "\n ", plot_data$count)

# Make the plot
ggplot(plot_data, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=type)) +
  facet_wrap(~name, scales="free") +
  geom_rect() +
  geom_text( x=1.2, aes(y=labelPosition, label=label, color=type), size=5) + # x here controls label position (inner / outer)
  scale_fill_manual(
    values=c("#264653",  "#2a9d8f","#e9c46a")
  ) +
  scale_color_manual(
    values=c("#264653",  "#2a9d8f","#e9c46a")
  ) +
  coord_polar(theta="y") +
  xlim(c(-1, 4)) +
  theme_void() +
  theme(legend.position = "none",
        #increase font size of facet label
        strip.text = element_text(size = 22)
        )



```







## Figure 3. Do we know how many children are alive, healthy, and learning?

This figure examines the availability of data between `r params$lwr_year` and `r params$upr_year` for the following indicators:

  - Proportion of children under 5 years of age whose births have been registered with a civil authority (% of children under 5 years of age)
  - Stunting, height for age (% of children under 5)
  - Internationally comparable learning assessment

```{r}
#| label: waffle_clean_data

#In what follows a set of availability metrics will be calculated for each country.
#The availability metrics are the following check for the availability of the data for each indicator in the dataset in a given time period

availability_df <- wdi_df %>%
  janitor::clean_names() %>%
  group_by(country) %>%
  mutate(    #birth registration
    birth_registration_under5 = na.locf(birth_registration_under5, na.rm = FALSE),
    birth_registration_under5=if_else(is.na(birth_registration_under5), 0, birth_registration_under5)
  ) %>%
  ungroup() %>%
  filter(date >= params$lwr_year & date <= params$upr_year) %>% #filter the data to the years of interest
  mutate( #calculate availability for each indicator
    SE_LPV_PRIM_avail = !is.na(se_lpv_prim),
    SE_LPV_PRIM_LD_avail = !is.na(se_lpv_prim_ld),
    clo_avail = !is.na(clo_avail),
    #stuting
    stunting_avail= !is.na(stunting),

    #calculate total population age 5- 14 
    population_5_14=sp_pop_0509_ma+sp_pop_1014_ma+sp_pop_0509_fe+sp_pop_1014_fe,
    population_0_5=sp_pop_0004_ma+sp_pop_0004_fe,
    #learning assessment availability
    learning_assessment_avail = clo_avail >= 1  | SE_LPV_PRIM_LD_avail >= 1 , #either clo or learning poverty available

  ) %>%
  #group by country and calculate the overall availability for each indicator in the span
  group_by(country) %>%
  mutate(    
    #take latest non-missing values of SPI and GDP
    SPI = na.locf(iq_spi_ovrl, na.rm = FALSE),
    GDP = na.locf(ny_gdp_pcap_pp_kd, na.rm = FALSE),
    population = na.locf(sp_pop_totl, na.rm = FALSE), #take latest non-missing value of population
    population_under25=na.locf(population_under25, na.rm = FALSE)
    ) %>%
  #arrange descending by date
  arrange(desc(date)) %>%
  summarise( #create counts of the availability for each indicator

    learning_assessment_avail = sum(learning_assessment_avail, na.rm = TRUE),
    learning_assessment_notavail=if_else(learning_assessment_avail==0, 1, 0),
    stunting_avail= sum(stunting_avail, na.rm = TRUE),
    stunting_notavail=if_else(stunting_avail==0, 1, 0),
    birth_registration_under5 = first(birth_registration_under5/100),
    no_birth_registration_under5 = 1-birth_registration_under5,
    SPI = first(SPI), #take the most recent value of SPI
    gdp_pcap_ppp = first(GDP), #take the most recent value of GDP per capita
    population = first(population), #take the most recent value of population
    population_under25 = first(population_under25), #take the most recent value of population
    population_5_14 = first(population_5_14), #take the most recent value of population
    population_0_5=first(population_0_5),


  ) %>% 

  #join with the country metadata
  left_join(wb_metadata) 



```


```{r}
#| label: waffledata
#| fig-width: 10
#| fig-height: 8

#create a waffle chart of the availability of indicators
#prep the data

waffle_data <- availability_df %>%
  select(iso3c, learning_assessment_notavail, no_birth_registration_under5, stunting_notavail, population_5_14,population_0_5, population_under25, region) %>%
  #add population weights
  mutate(
    learning_assessment_notavail=as.numeric(learning_assessment_notavail)*(population_5_14),
    no_birth_registration_under5=as.numeric(no_birth_registration_under5)*(population_0_5),
    stunting_notavail=as.numeric(stunting_notavail)*(population_0_5)
  ) %>%
  #stack learning assessment, school enrollment, and finance availability
  pivot_longer(
    cols = c(learning_assessment_notavail, no_birth_registration_under5, stunting_notavail),
    names_to = "indicator",
    values_to = "availability"
  ) %>%
  #create population with an indicaor for each
  mutate(
    #Indicator is the number of children in each country if data not available. 0 if  data available
    indicator_not_avail_pop=as.numeric(availability),
    #label indicator
    indicator=case_when(
      indicator=="learning_assessment_notavail" ~ "Learning\n Assessment",
      indicator=="no_birth_registration_under5" ~ "Birth\n Registration",
      indicator=="stunting_notavail" ~ "Stunting"
    )
  ) %>%
  mutate(pop=if_else(indicator!="Learning\n Assessment", (population_0_5), (population_5_14)),
         indicator=factor(indicator, levels=c("Birth\n Registration","Stunting", "Learning\n Assessment"))) 
    
#aggregate data to regional level
waffle_data_region <- waffle_data %>%
  group_by(region, indicator) %>%
  summarise(
    indicator_not_avail_pop = sum(indicator_not_avail_pop, na.rm = TRUE),
    pop= sum(pop, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(share=indicator_not_avail_pop/pop) %>%
  rename(Region=region)

#get global totals
global_totals <- waffle_data_region %>%
  group_by(indicator) %>%
  summarise(
    indicator_not_avail_pop = sum(indicator_not_avail_pop, na.rm = TRUE),
    pop=sum(pop, na.rm=TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    share=indicator_not_avail_pop/pop
  )


#produce plot
waffle_data_region_scaled <-  waffle_data_region %>%
  #scale down size of population to make each square represent 1000 children
  mutate(
    indicator_not_avail_pop = round(indicator_not_avail_pop/1000000,0),
    x=case_when(
      indicator=="Learning\n Assessment" ~ 70,
      indicator=="Stunting" ~ 30,
      indicator=="Birth\n Registration" ~ 25
    ),
    y=7,
    label=case_when(
      indicator=="Learning\n Assessment" ~ "772 million\n children\n age 5-14",
      indicator=="Stunting" ~ "292 million\n children\n under 5",
      indicator=="Birth\n Registration" ~ "207 million\n children\n under 5"
    )
  )





p1<-ggplot(
  waffle_data_region_scaled
) +
  waffle::geom_waffle(
    aes(values=indicator_not_avail_pop,fill=Region),
    n_rows = 12, 
    flip = FALSE, na.rm=TRUE, color='white',
  ) +
  facet_grid(
    indicator~1, 
    switch="both"
  ) +
  scale_x_discrete(expand = expansion(mult = c(0.1, 0.1))) +  # Add padding on both sides
  scale_fill_manual(values=region_colors)+
  coord_equal()  + 
  geom_text(
            aes(x = x,y=y, label = label),
  size = 5,
  show.legend = FALSE)



p2<-p1+
  # Hide legend
  guides(fill=guide_legend(title="",ncol=1),color='none')+
  # Add title and subtitle
  #labs(subtitle="More than 772 million children are missing a comparable learning assessment.<br>292 million children are in a country with no recent data about stunting.<br>209 million children's births are not registered in their countries CRVS.") +
  labs(
  caption = "**Note:** Each square represents 1 million children.<br>
    - 32% of children under 5 lack birth registration (207 out of 655 million).<br>
    - 45% of children under 5 are missing stunting data (292 out of 655 million).<br>
    - 57% of children aged 5-14 lack learning assessment data (772 out of 1,350 million)."
  ) +
  #expand limit of x axis
    theme(
    # Enable markdown for title and subtitle
    plot.title=element_markdown(size=16),
    plot.subtitle=element_markdown(size=14),
    plot.caption = element_markdown(hjust=0, size=12),
    legend.text=element_text(size=12),
    # "Clean" facets "
    panel.background=element_rect(fill="white"),
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks = element_blank(),
    #change font of the geom_text
    text=element_text(size=12, 'Helvetica'),
    strip.background.y = element_rect(fill="white"),
    strip.background.x = element_rect(fill="white"),
    strip.text.y = element_text(color="black", size=14),
    strip.text.x = element_text(color="white"),
    legend.position=c(.8,.7)


  ) 
p2
```




Chart shows the number of children missing key data. Each square represents 2 million children, colored according to region.

Source: World Bank. Learning assessment data is from the World Bank's Learning Poverty and Country Learning Outcomes database. Stunting data availability is from the UNICEF/WHO/The World Bank: Joint child malnutrition estimates (JME) database. Birth registration data is from the UNSD Population and Vital Statistics Report.

For learning assessments, the number shown is the count of all children age 5-14 living in a country where no internationally comparable learning assessment has taken place since `r params$lwr_year`. For Stunting, the number shown is the count of all children under 5 living in a country where no stunting data has been collected since `r params$lwr_year`. For birth registration, the number shown is the count of all children under 5 living in a country multiplied times the proportion of births not registered in the country using the CRVS. To produce the proportion of births not registered, the CRVS is compared to other data sources, such as the DHS or census.

Note: More than 772 million children are missing a comparable learning assessment. 292 million children are in a country with no recent data about stunting. 207 million children's births are not registered in their countries CRVS.


## Figure 4. Are some countries better at measuring SDG outcomes for children?

[This figure has 3 panels: (a) World Bank regions on y axis and SDG child outcome indicator availability (%) on x axis, (b) World Bank income groups on y axis and SDG child outcome indicator availability (%) on x axis, (c) scatter of availability of SDG child outcome indicators and Statistical Performance Index score ]

There are 181 countries, after applying population restrictions. The availability of data is measured as the percentage of countries with data available in the past `r upper_year-lower_year+1` years. 


```{r}
#| label: fig4data

avail_plt_df <- country_data_availability_combined_df %>%
    filter(Child_SDG == 1) %>%
    filter(Outcome_Functioning_SDG == 1) %>%
    filter(!iso3c %in% pop_exlude_cntry) %>%
    mutate(availability = 100 * availability) %>% # convert ind_available measure which is 0-1 to percentage available by multiplying by 100
    # collapse to the country level
    group_by(iso3c) %>%
    summarise(availability = mean(availability, na.rm = T)) %>%
    left_join(wdi_df %>% filter(date == 2022)) %>%
    ungroup()





```


### Panel A. World Bank regions

```{r}
#| label: fig_availchart1
#| fig-cap: "Child SDG Outcome Indicator availability by region"
#| fig-width:  9
#| fig-height: 6

# calculate global average
world_avg <-
    avail_plt_df %>%
    ungroup() %>%
    summarise(avg = mean(availability, na.rm = T)) %>%
    pull(avg)

world_p25 <- scales::comma(quantile(avail_plt_df$availability, p = 0.25, na.rm = TRUE))
world_p50 <- scales::comma(quantile(avail_plt_df$availability, p = 0.5, na.rm = TRUE))
world_p75 <- scales::comma(quantile(avail_plt_df$availability, p = 0.75, na.rm = TRUE))

# calculate regional average
reg_avg <-
    avail_plt_df %>%
    filter(!is.na(region)) %>%
    group_by(region) %>%
    summarise(avg = mean(availability, na.rm = T)) %>%
    arrange(-avg)

reg_avg <- reg_avg %>%
    mutate(region = factor(region, levels = reg_avg$region))


#calculate the number of countries above 50
n_countries_above_50 <- avail_plt_df %>%
    filter(availability > 50) %>%
    nrow()

# set annotatino arrows
arrows <-
    tibble(
        x1 = c(5.2, 6.62),
        x2 = c(4.6, 7),
        y1 = c(world_avg + 20, 30),
        y2 = c(world_avg + 2, 38)
    )




avail_plt_df %>%
    filter(!is.na(region)) %>%
    mutate(region = factor(region, levels = reg_avg$region)) %>%
    ggplot(aes(y = availability, x = region, color = region)) +
    geom_segment(
        data = reg_avg,
        aes(
            x = region, xend = region,
            y = world_avg, yend = avg
        ),
        size = 0.8
    ) +
    # geom_boxplot(aes(color=region), outlier.alpha = 0) +
    geom_jitter(aes(size = population_under25), alpha=0.7, width = 0.2, height=0) +
    # geom_point(size = 3, alpha = 0.15) +
    # stat_summary(fun = mean, geom = "text", size = 5, color='black') +
    geom_label(data = reg_avg, aes(y = avg, x = region, label = round(avg, 1)), size=5, vjust=-0.5, fontface=2, position = position_dodge()) +
    geom_hline(aes(yintercept = world_avg), color = "gray70", size = 0.6) +
    #labs(caption = str_wrap(paste0("The number of countries with more than 50% availability is ",n_countries_above_50,". The 25th percentile of the SDG availability is ", world_p25, "%. The median is ", world_p50, "% and the 75th percentile is ", world_p75, "%.", " Means are unweighted.  Circles are sized according to population"), 120)) +
    bbc_style() +
    coord_flip() +
    ylab("Child SDG Outcome Indicator Availability") +
    #apply region color palette
    scale_color_manual(values = region_colors) +
    # scale_y_continuous(
    #   labels=scales::comma
    # ) +
    # scale_y_log10(
    #   labels=scales::comma
    # ) +
    expand_limits(y = c(0, 100)) +
    theme(
        legend.position = "none",
        axis.title.y = element_blank(),
        text = element_text(size = 14)
    ) +
    annotate( # annotations
        "text",
        x = 5.5, y = 75, family = "Poppins", size = 5, color = "gray20", lineheight = .9,
        label = glue::glue("Average across all countries:\n{round(world_avg, 1)}%")
    ) 
    # annotate(
    #     "text",
    #     x = 6.5, y = 30, family = "Poppins", size = 4, color = "gray20",
    #     label = str_wrap("Regional average", 15)
    # ) +
    # geom_curve( # add curves for annotatino
    #     data = arrows, aes(x = x1, y = y1, xend = x2, yend = y2),
    #     arrow = arrow(length = unit(0.08, "inch")), size = 0.5,
    #     color = "gray20", curvature = -0.3
    # )

# reg_avg %>% flextable()

```

The number of countries with more than 50% availability is `r n_countries_above_50`. The 25th percentile of the SDG availability is `r world_p25`%. The median is `r world_p50`% and the 75th percentile is `r world_p75`%. Means are unweighted.  Circles are sized according to population.

### Panel B. World Bank income groups

```{r }
#| label: fig_availchart2
#| fig-cap: "Child Outcome SDG Indicator availability by income"
#| fig-width:  9
#| fig-height: 6
# calculate regional average
inc_avg <-
    avail_plt_df %>%
    # mutate(income_level = ifelse(iso3c == "VEN", "Upper middle income", income_level)) %>%
    filter(!is.na(income_level) & income_level != "Not classified") %>%
    group_by(income_level) %>%
    summarise(avg = mean(availability, na.rm = T)) %>%
    arrange(-avg) %>%
    ungroup()

avail_plt_df <- avail_plt_df %>%
    mutate(income_level = factor(income_level, levels = c(
        "High income", "Upper middle income",
        "Lower middle income", "Low income"
    )))
# set annotatino arrows
arrows <-
    tibble(
        x1 = c(3.2, 1.5),
        x2 = c(2.5, 1.15),
        y1 = c(world_avg + 20, 30),
        y2 = c(world_avg + 2, 41)
    )

#calculate the number of countries above 50
n_countries_above_50 <- avail_plt_df %>%
    filter(availability > 50) %>%
    nrow()

avail_plt_df %>%
    filter(!is.na(income_level)) %>%
    mutate(income_level = ordered(income_level, levels = c(
        "High income", "Upper middle income",
        "Lower middle income", "Low income"
    ))) %>%
    arrange(income_level) %>%
    ggplot(aes(
        y = availability, x = income_level,
        color = income_level
    )) +
    geom_segment(
        data = inc_avg,
        aes(
            x = income_level, xend = income_level,
            y = world_avg, yend = avg
        ),
        size = 0.8
    ) +
    # geom_boxplot(aes(color=region), outlier.alpha = 0) +
    geom_jitter(aes(size = population_under25), alpha=0.7, width = 0.2, height=0) +
    # geom_point(size = 3, alpha = 0.15) +
    # stat_summary(fun = mean, geom = "point", size = 5, color='black') +
    geom_label(data = inc_avg, aes(y = avg, x = income_level, label = scales::comma(round(avg, 1))), vjust=-1.2, fontface=2, size=5, position = position_dodge()) +
    # geom_text(data=reg_avg, aes(y=avg, x=region, label=scales::comma(round(avg,1))), color="black") +
    geom_hline(aes(yintercept = world_avg), color = "gray70", size = 0.6) +
    # labs(caption = str_wrap(paste0("The number of countries with more than 50% availability is ",n_countries_above_50,". The 25th percentile of the SDG availability is ", world_p25, "%. The median is ", world_p50, "% and the 75th percentile is ", world_p75, "%.", " Means are unweighted.  Circles are sized according to population"), 120)) +
  #apply income group color pallete
  scale_color_manual(values = income_colors) +
  bbc_style() +
    coord_flip() +
    expand_limits(y = c(0, 100)) +
    ylab("SDG Child Outcome Indicator Availability") +
    scale_x_discrete(
        limits = levels(avail_plt_df$income_level),
        breaks = levels(avail_plt_df$income_level)
    ) +
    # scale_y_log10(
    #   labels=scales::comma
    # ) +
    theme(
        legend.position = "none",
        axis.title.y = element_blank(),
        text = element_text(size = 14)
    ) +
    annotate( # annotations
        "text",
        x = 3.35, y = 75, family = "Poppins", size = 5, color = "gray20", lineheight = .9,
        label = glue::glue("Average across all\ncountries: {round(world_avg, 1)}%")
   ) 
    # annotate(
    #     "text",
    #     x = 1.4, y = 30, family = "Poppins", size = 4, color = "gray20",
    #     label = str_wrap("income level average", 15)
    # ) +
    # geom_curve( # add curves for annotatino
    #     data = arrows, aes(x = x1, y = y1, xend = x2, yend = y2),
    #     arrow = arrow(length = unit(0.08, "inch")), size = 0.5,
    #     color = "gray20", curvature = -0.3
    # )

```

The number of countries with more than 50% availability is `r n_countries_above_50`. The 25th percentile of the SDG availability is `r world_p25`%. The median is `r world_p50`% and the 75th percentile is `r world_p75`%. Means are unweighted.  Circles are sized according to population.

## Figure 5. Availability of Child Outcome SDG Indicators and Statistical Capacity 

```{r}
#| label: fig_availchart3
#| fig-cap: "Plot of SPI overall score and Availability of child outcome SDG indicators."
#| fig-width:  9
#| fig-height: 6


eq_location <- data.frame(
    x = 10,
    y = 10
)

#check quantile stats
spi_groups_quantiles <- quantile(avail_plt_df$IQ.SPI.OVRL, probs=c(1,2,3,4)/5,na.rm=T)
  
SPI_quantiles <- avail_plt_df %>%
    mutate(spi_groups=case_when(
      between(IQ.SPI.OVRL, spi_groups_quantiles[4],100) ~ "Top Quintile",
      between(IQ.SPI.OVRL, spi_groups_quantiles[3],spi_groups_quantiles[4]) ~ "4th Quintile",
      between(IQ.SPI.OVRL, spi_groups_quantiles[2],spi_groups_quantiles[3]) ~ "3rd Quintile",
      between(IQ.SPI.OVRL, spi_groups_quantiles[1],spi_groups_quantiles[2]) ~ "2nd Quintile",
      between(IQ.SPI.OVRL, 0,spi_groups_quantiles[1]) ~ "Bottom 20%"
      
    )) %>%
    mutate(spi_groups=factor(spi_groups, 
                             levels=c("Top Quintile","4th Quintile","3rd Quintile","2nd Quintile","Bottom 20%" ))) %>%
    group_by(spi_groups) %>%
    summarise(
      avg = mean(availability, na.rm = T)
    ) 

# plot SPI scores against availability
spi_plt <- avail_plt_df %>%
    rename(Income=income_level) %>%
    ggplot(aes(x = IQ.SPI.OVRL, y = availability)) +
    geom_point(aes(fill = Income, size=population_under25), alpha=0.7, color = "grey", pch = 21) +
    geom_smooth(method = "lm") +
    theme_spi() +
    xlab("SPI Overall Score") +
    ylab("Availability of Child Outcome SDG Indicators (%)") +
    geom_richtext(
        data = eq_location, aes(x = x, y = y, label = eq_plot_txt(avail_plt_df, "IQ.SPI.OVRL", "availability")), hjust = 0.2, color='black'
    ) +
    scale_fill_manual(values = income_colors) +
    scale_size_continuous(range = c(2,6),
                          guide=FALSE) +
    theme(legend.position = "bottom",
          #increase font size of axis title
          axis.title = element_text(size=14),
          legend.text = element_text(size=11)) +
    expand_limits(
        x = c(0, 100),
        y = c(0, 70)
    ) 
    # labs(
    #     title = "Plot of SPI overall score and Availability of Child SDG Indicators",
    #     caption = str_wrap("Source: SPI Overall Score from the World Development Indicators (IQ.SPI.OVRL).  The availability of Child Outcome SDG Indicators based on authors calculations based on the UN Global SDG Database.", 100)
    # )

spi_plt
```

Source: SPI Overall Score from the World Development Indicators (IQ.SPI.OVRL).  The availability of Child Outcome SDG Indicators based on authors calculations based on the UN Global SDG Database.

The graph illustrates the relationship between the availability of child outcome SDG indicators and the Statistical Performance Index (SPI) overall score. The SPI is a composite measure of a country's statistical capacity, with higher scores reflecting stronger performance. A 10-point increase in the SPI score is associated with a 4.4 percentage point rise in the availability of child outcome SDG indicators, a relationship that is statistically significant (p < 0.001). Notably, countries in the bottom 20% of the SPI score (those with scores below approximately 50) have significantly lower availability of these indicators, with only 25% coverage on average, compared to about 40% availability in the other quintiles on average.

## Figure 6. Statistical Capacity Improvements over Time.

SPI Overall scores have risen by 20% since 2016, with the largest increases in the data accessibility provided by statistical systems, such as making existing statistics easier to find online. While the availability of online statistics has improved, access to microdata needed for computing child-disaggregated breakdowns remains a significant issue. [Ekhator-Mobayode & Hoogeveen (2021)](https://documents1.worldbank.org/curated/en/949901640829231412/pdf/Microdata-Collection-and-Openness-in-the-Middle-East-and-North-Africa-MENA-Introducing-the-MENA-Microdata-Access-Indicator.pdf) highlighted this problem in the Middle East and North Africa (MENA) region, where only 25 out of 140 potential datasets were accessible through National Statistical Offices (NSOs) or international repositories. Furthermore, the collection of underlying survey data has barely improved since 2016, as indicated by the SPI Data Sources score increasing by only 2% during this period. This stagnation persists despite advancements in data collection tools, such as Computer-Assisted Personal Interview (CAPI) software, which have made it easier than ever to gather data.


```{r}
#| label: fig_spitrend
#| fig-cap: "SPI Overall Score and its components over time"
#| fig-width:  9
#| fig-height: 6

#plot the SPI trend
global_avg <- wdi_df %>%
  janitor::clean_names() %>%
  filter(date>2015) %>%
  group_by(date) %>%
  summarise(
    `SPI Overall Score` = mean(iq_spi_ovrl, na.rm = TRUE),
    `SPI Data Sources Score` = mean(iq_spi_pil4, na.rm = TRUE),
    `SPI Data Services Score` = mean(iq_spi_pil2, na.rm = TRUE)
  )

#plot the trends
global_avg %>%
  ggplot(aes(x=date)) +
  geom_line(aes(y=`SPI Overall Score`, color='SPI Overall Score')) +
  geom_line(aes(y=`SPI Data Sources Score`, color="Data Collection")) +
  geom_line(aes(y=`SPI Data Services Score`, color="Data Accessibility")) +
  geom_point(aes(y=`SPI Overall Score`, fill='SPI Overall Score'), shape = 21, size=2, stroke=1) +
  geom_point(aes(y=`SPI Data Sources Score`, fill="Data Collection"), shape = 21, size=2, stroke=1) +
  geom_point(aes(y=`SPI Data Services Score`, fill="Data Accessibility"), shape = 21, size=2, stroke=1) +
  scale_color_manual(
    values=c(
      "SPI Overall Score" = "black",
      "Data Collection" = "#e56666",
      "Data Accessibility" = "#2b98c6"
    )
  ) +
  scale_fill_manual(
    values=c(
      "SPI Overall Score" = "black",
      "Data Collection" = "#e56666",
      "Data Accessibility" = "#2b98c6"
    )
  ) +
  expand_limits(y=c(20,80)) +
  theme_minimal() +
  ylab("SPI Index Score (0-100)") +
  labs(color="") +
  guides(fill='none') +
  xlab("Year") +
  theme(
    axis.title = element_text(size=14),
    axis.text = element_text(size=12),
    legend.position = 'top',
    legend.text = element_text(size=11)
  ) 

```
Note. SPI Overall Score is a composite measure of statistical capacity, with higher scores indicating better statistical performance. The SPI is composed of five pillars: data use, data services (data accessibility), data products, data sources, and data infrastructure. More information can be found in [Dang, Pullinger, Serajuddin, & Stacy (2023)](https://www.nature.com/articles/s41597-023-01971-0). The Data Collection score (SPI Data Sources Score) measures whether recent censuses or surveys have been conducted, as well as the availability of CRVS and some types of geospatial data.  while the Data Accessibility score (SPI Data Services Score) measures the availability of online statistics and data services provided by statistical systems.


# Annex

## Table 1. How much data do we have on SDG outcomes for children? (N=181 countries, years covered: 2019-2024)

[This is a table that takes a subset of the indicators used in Figure 2 – the ones related to children –and shows coverage. The table shows a list of the indicators while the cells show the percent of countries with a value in the past `r upper_year-lower_year+1` years]. Countries with a smaller population are excluded from the analysis.

```{r}
#| label: table1
#| fig-cap: "How much data do we have on SDG outcomes for children?"

# prepare the data for the table
# filter indicator_availabilty_df to just the child indicators
child_indicator_availability_df <- indicator_availability_combined_df %>%
    filter(Child_SDG == 1) %>%
    filter(Outcome_Functioning_SDG == 1) %>%
    mutate(
        n_countries = as.character(round(n_countries * ind_available, 0)),
        any_available = round(any_available, 3) * 100,
        ind_available = round(ind_available, 3) * 100,
        age_available = round(age_available, 3) * 100
    ) %>%
    # replace values as missing for age_available if Flag_Check_Age_ChildrenSeparate==0
    mutate(age_available = if_else(Flag_Check_Age_ChildrenSeparate == 0, "Not Applicable", paste0(age_available,"%"))) %>%
    rename(
        "Share of Countries with Any Data Available (%)" = any_available,
        "Share of Countries with Any Non-Modelled Data Available (%)" = ind_available,
        "Share of Countries with Child Disaggregated Data Available (%)" = age_available,
    ) %>%
    rename_at(
        vars(n_countries),
        ~ paste0("Number of Countries with data: ", lower_year, " - ", upper_year)
    ) %>%
    rename(
        Goal = goal,
        Indicator = code,
        Description = description
    ) %>%
    # create Goal as factor variable and sort on this. There are 17 goals
    mutate(Goal = factor(Goal, levels = c(1:17))) %>%
    arrange(desc(Flag_Check_Age_ChildrenSeparate), Goal)  %>%
    mutate(Type=if_else(Flag_Check_Age_ChildrenSeparate==1, "Data for Children is a Disaggregation", "Data for Children is a Separate Indicator")) %>%
    select(Type, Goal, Indicator, Description, `Share of Countries with Any Data Available (%)`, `Share of Countries with Child Disaggregated Data Available (%)`) 

# use flextable to create table
child_indicator_availability_df %>%
    as_grouped_data(groups=c('Type')) %>%
    as_flextable() %>%
    bold(j = 1, i = ~ !is.na(Type), bold = TRUE, part = "body") %>%
  bold(part = "header", bold = TRUE) %>%
    merge_v(j = "Goal") %>%
    set_formatter(`Share of Countries with Any Data Available (%)` = function(x) sprintf("%.1f%%", x)) %>%
    #set_formatter(`Share of Countries with Any Non-Modelled Data Available (%)` = function(x) sprintf("%.1f%%", x)) %>%
    #set_formatter(`Share of Countries with Child Data Available (%)` = function(x) sprintf("%.1f%%", x)) %>%
    theme_vanilla() %>%
    add_footer_lines(values = "Source: UN.") %>%
    FitFlextableToPage() %>%
    set_table_properties(width = .5, layout = "autofit")

```



## Table 2. How much data is modelled?

```{r}
#| label: table2
#| fig-cap: "How much data is modelled?"

# prepare the data for the table
modelled_indicator_availability_df <- indicator_availability_combined_df %>%
    filter(Child_SDG == 1) %>%
    filter(Outcome_Functioning_SDG == 1) %>%
    select(code, goal, description, ind_available, ind_modelled, age_available, age_modelled, n_countries)

# table with average share of modelled data by goal
tab2 <- modelled_indicator_availability_df %>%
    group_by(goal) %>%
    summarise(
        `Share of Countries with Modelled Data (%)` = round(mean(ind_modelled, na.rm = T) * 100, 1),
        `Share of Countries with Child Modelled Data (%)` = round(mean(age_modelled, na.rm = T) * 100, 1)
    ) %>%
    rename(
        Goal = goal
    ) %>%
    mutate(Goal = factor(Goal, levels = c(1:17))) %>%
    arrange(Goal)

flextable(tab2) %>%
    merge_v(j = "Goal") %>%
    set_formatter(`Share of Countries with Modelled Data (%)` = function(x) sprintf("%.1f%%", x)) %>%
    set_formatter(`Share of Countries with Child Modelled Data (%)` = function(x) sprintf("%.1f%%", x)) %>%
    theme_vanilla() %>%
    add_footer_lines(values = "Source: UN.") %>%
    FitFlextableToPage() %>%
    set_table_properties(width = .5, layout = "autofit")



```


## Figure A1. Are some countries better at measuring SDG outcomes for HD?

[This figure has 3 panels: (a) World Bank regions on y axis and SDG HD outcome indicator availability (%) on x axis, (b) World Bank income groups on y axis and SDG HD outcome indicator availability (%) on x axis, (c) scatter of availability of SDG HD outcome indicators and Statistical Performance Index score ]

There are 181 countries, after applying population restrictions. The availability of data is measured as the percentage of countries with data available in the past `r upper_year-lower_year+1` years. 


```{r}
#| label: figA1data

avail_plt_hd_df <- country_data_availability_combined_df %>%
    filter(HD_SDG == 1) %>%
    filter(Outcome_Functioning_SDG == 1) %>%
    mutate(availability = 100 * availability) %>% # convert ind_available measure which is 0-1 to percentage available by multiplying by 100
    # collapse to the country level
    group_by(iso3c) %>%
    summarise(availability = mean(availability, na.rm = T)) %>%
    left_join(wdi_df %>% filter(date == 2022)) %>%
    ungroup()





```


### Panel A. World Bank regions

```{r}
#| label: fig_availchartA1
#| fig-cap: "HD SDG Outcome Indicator availability by region"
#| fig-width:  9
#| fig-height: 6

# calculate global average
world_avg <-
    avail_plt_hd_df %>%
    ungroup() %>%
    summarise(avg = mean(availability, na.rm = T)) %>%
    pull(avg)

world_p25 <- scales::comma(quantile(avail_plt_hd_df$availability, p = 0.25, na.rm = TRUE))
world_p50 <- scales::comma(quantile(avail_plt_hd_df$availability, p = 0.5, na.rm = TRUE))
world_p75 <- scales::comma(quantile(avail_plt_hd_df$availability, p = 0.75, na.rm = TRUE))

# calculate regional average
reg_avg <-
    avail_plt_hd_df %>%
    filter(!is.na(region)) %>%
    group_by(region) %>%
    summarise(avg = mean(availability, na.rm = T)) %>%
    arrange(-avg)

reg_avg <- reg_avg %>%
    mutate(region = factor(region, levels = reg_avg$region))

#calculate the number of countries above 50
n_countries_above_50 <- avail_plt_hd_df %>%
    filter(availability > 50) %>%
    nrow()
# set annotatino arrows
arrows <-
    tibble(
        x1 = c(5.2, 6.62),
        x2 = c(4.6, 7),
        y1 = c(world_avg + 20, 30),
        y2 = c(world_avg + 2, 38)
    )




avail_plt_hd_df %>%
    filter(!is.na(region)) %>%
    mutate(region = factor(region, levels = reg_avg$region)) %>%
    ggplot(aes(y = availability, x = region, color = region)) +
    geom_segment(
        data = reg_avg,
        aes(
            x = region, xend = region,
            y = world_avg, yend = avg
        ),
        size = 0.8
    ) +
    # geom_boxplot(aes(color=region), outlier.alpha = 0) +
    geom_jitter(aes(size = SP.POP.TOTL), alpha=0.4, width = 0.2) +
    # geom_point(size = 3, alpha = 0.15) +
    # stat_summary(fun = mean, geom = "text", size = 5, color='black') +
    geom_text(data = reg_avg, aes(y = avg, x = region, label = round(avg, 1)), color = "black", position = position_dodge()) +
    geom_hline(aes(yintercept = world_avg), color = "gray70", size = 0.6) +
    labs(caption = str_wrap(paste0("The number of countries with more than 50% availability is ",n_countries_above_50,". The 25th percentile of the SDG availability is ", world_p25, "%. The median is ", world_p50, "% and the 75th percentile is ", world_p75, "%.", " Means are unweighted.  Circles are sized according to population"), 120)) +
    theme_bw() +
    coord_flip() +
    ylab("HD SDG Outcome Indicator Availability") +
    # scale_y_continuous(
    #   labels=scales::comma
    # ) +
    # scale_y_log10(
    #   labels=scales::comma
    # ) +
    expand_limits(y = c(0, 100)) +
    theme(
        legend.position = "none",
        axis.title.y = element_blank(),
        text = element_text(size = 14)
    ) +
    annotate( # annotations
        "text",
        x = 5.5, y = 75, family = "Poppins", size = 4, color = "gray20", lineheight = .9,
        label = glue::glue("Average across all countries:\n{round(world_avg, 1)}%")
    ) +
    annotate(
        "text",
        x = 6.5, y = 30, family = "Poppins", size = 4, color = "gray20",
        label = str_wrap("Regional average", 15)
    ) +
    geom_curve( # add curves for annotatino
        data = arrows, aes(x = x1, y = y1, xend = x2, yend = y2),
        arrow = arrow(length = unit(0.08, "inch")), size = 0.5,
        color = "gray20", curvature = -0.3
    )

# reg_avg %>% flextable()

```

### Panel B. World Bank income groups

```{r }
#| label: fig_availchartA2
#| fig-cap: "HD Outcome SDG Indicator availability by income"
#| fig-width:  9
#| fig-height: 6
# calculate regional average
inc_avg <-
    avail_plt_hd_df %>%
    # mutate(income_level = ifelse(iso3c == "VEN", "Upper middle income", income_level)) %>%
    filter(!is.na(income_level) & income_level != "Not classified") %>%
    group_by(income_level) %>%
    summarise(avg = mean(availability, na.rm = T)) %>%
    arrange(-avg) %>%
    ungroup()

avail_plt_hd_df <- avail_plt_hd_df %>%
    mutate(income_level = factor(income_level, levels = c(
        "High income", "Upper middle income",
        "Lower middle income", "Low income"
    )))

#calculate the number of countries above 50
n_countries_above_50 <- avail_plt_hd_df %>%
    filter(availability > 50) %>%
    nrow()

# set annotatino arrows
arrows <-
    tibble(
        x1 = c(3.2, 1.5),
        x2 = c(2.5, 1.15),
        y1 = c(world_avg + 20, 30),
        y2 = c(world_avg + 2, 41)
    )

avail_plt_hd_df %>%
    filter(!is.na(income_level)) %>%
    mutate(income_level = ordered(income_level, levels = c(
        "High income", "Upper middle income",
        "Lower middle income", "Low income"
    ))) %>%
    arrange(income_level) %>%
    ggplot(aes(
        y = availability, x = income_level,
        color = income_level
    )) +
    geom_segment(
        data = inc_avg,
        aes(
            x = income_level, xend = income_level,
            y = world_avg, yend = avg
        ),
        size = 0.8
    ) +
    # geom_boxplot(aes(color=region), outlier.alpha = 0) +
    geom_jitter(aes(size = SP.POP.TOTL), alpha=0.4, width = 0.2) +
    # geom_point(size = 3, alpha = 0.15) +
    # stat_summary(fun = mean, geom = "point", size = 5, color='black') +
    geom_text(data = inc_avg, aes(y = avg, x = income_level, label = scales::comma(round(avg, 1))), color = "black", position = position_dodge()) +
    # geom_text(data=reg_avg, aes(y=avg, x=region, label=scales::comma(round(avg,1))), color="black") +
    geom_hline(aes(yintercept = world_avg), color = "gray70", size = 0.6) +
    labs(caption = str_wrap(paste0("The number of countries with more than 50% availability is ",n_countries_above_50,". The 25th percentile of the SDG availability is ", world_p25, "%. The median is ", world_p50, "% and the 75th percentile is ", world_p75, "%.", " Means are unweighted.  Circles are sized according to population"), 120)) +
    theme_bw() +
    coord_flip() +
    expand_limits(y = c(0, 100)) +
    ylab("SDG HD Outcome Indicator Availability") +
    scale_x_discrete(
        limits = levels(avail_plt_hd_df$income_level),
        breaks = levels(avail_plt_hd_df$income_level)
    ) +
    # scale_y_log10(
    #   labels=scales::comma
    # ) +
    theme(
        legend.position = "none",
        axis.title.y = element_blank(),
        text = element_text(size = 14)
    ) +
    annotate( # annotations
        "text",
        x = 3.35, y = 75, family = "Poppins", size = 4, color = "gray20", lineheight = .9,
        label = glue::glue("Average across all\ncountries: {round(world_avg, 1)}%")
    ) +
    annotate(
        "text",
        x = 1.4, y = 30, family = "Poppins", size = 4, color = "gray20",
        label = str_wrap("income level average", 15)
    ) +
    geom_curve( # add curves for annotatino
        data = arrows, aes(x = x1, y = y1, xend = x2, yend = y2),
        arrow = arrow(length = unit(0.08, "inch")), size = 0.5,
        color = "gray20", curvature = -0.3
    )

```

